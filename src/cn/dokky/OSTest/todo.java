package cn.dokky.OSTest;

public class todo {
    //首先有了PCB结点


    /*要实现一个等待队列 —— Waiting Queue --
    调度算法 就是：
    ①每次对这个队列的头元素进行操作——————相当于在处理机上运行
    ②然后根据算法把队头元素重新插回队列中（没运行完），或者从队列上取下来（运行完了）
    ③重复1、2步骤，直到所有进程都被运行完

    所以对应这个队列至少要有三个操作
    1.取头元素的操作   2.把元素再次insert的操作    3.size()用来判断队列是否清空的操作


    //主函数中的初始化操作
    初始化一个个PCB Node——其中大致包括：优先数、总共需要cpu时间片数、已经占用CPU时间片数
    初始化一个单向链表（按照优先数从高到低）
    进行I/O操作，询问用户想执行哪个调度算法
    根据反馈的不同，调用不同的调度算法（提供的参数都为等待队列对象）

    //优先数调度算法
    while(队列大小！=0)
    {
        取出第一个元素

        该元素的所需CPU时间片数--;
        优先数-3;
        if(所需时间片数=0)
        {
           设置状态为 F（Finished）;
        }
        重新插入队列

        //每次取队头元素就可以了，然后插入的时候就按照如果状态是W，则插入到合适位置，如果状态是F，则直接插入队尾
        （应该注意，所有队首的元素的state应该都是R 正在运行）
        （可以用一个insertcheck的函数，对每次插入完成后的队列，检查第一个元素是不是r，不是，改成R，后续元素的状态改成W或F）

         但这样可能会存在着，如果一个元素已经被取出来，那怎么输出呢，会不会同时有两个R呢


        size的操作每次只计数到state是F的时候为止


    }






*/
}
